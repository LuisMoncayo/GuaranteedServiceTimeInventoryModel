# Compute the safety stock cost in Table 2

In the file **main.py**, the user selects which supply chain instances to analyse. In this example, all 38 instances are evaluated simultaneously.


```{python}
list_instances = ['01','02','03','04','05','06','07','08','09','10',
                  '11','12','13','14','15','16','17','18','19','20',
                  '21','22','23','24','25','26','27','28','29','30',
                  '31','32','33','34','35','36','37','38']
```

The service level $\alpha$ and the guaranteed service time $\Phi$ are obtained from the data in **"MSOM-06-038-R2 Data Set in Excel.xls"**. The user must specify the holding cost $I$, which is set to 20% per year by default.

In line 266 of **main.py**, the user defines the time limit $T$ after which the Gurobi B\&C algorithm stops if no better solution is found. In the example shown below, the time limit is set to 10 minutes (i.e., $60 \times 10$ seconds).


```{python}
# Terminate if objective has not improved in 20s
if time.time() - model._time > 60*10:
  model.terminate()
```
# Generate the edge and depth Table 1 and 3, and Figure 2 and 3 

The data about the degree and edges showing in Table 1 and 3, and Figure 2 and 3 are computed the file **grpah_analysis.py**. The file models the supply chain as a digraph such as

```{python}
G = nx.from_pandas_edgelist(edges_data, create_using=nx.DiGraph() )
```
The edges_data is a pandas object with the $(i,j)\in E$.

The Tables are generated by 

```{python}
 print("Stage",",","Degree",",","In_Edges",",","Out_Edges",",","Depth")
    for i in G.nodes():
        print(i,",",G.degree(i),",",len(G.in_edges(i)),",",len(G.out_edges(i)),",",G.nodes[i]["depth"])
```

# Graph the supply chian using categorical data in Figure 4 and 6

To graph the plots with cateforical variables the **pyvis** package is used for creating interactive netwrok visualisations in html.

```{python}
from pyvis.network import Network
import networkx as nx
```
Therefore, for each supply chain the graph is created using by:

```{python}
nt = Network('1500px', '1500px', notebook=True, cdn_resources="remote", directed =True)
    nt.repulsion()
    # populates the nodes and edges data structures
    for node in nodes_data["Stage Name"]:
        if 'Dist' in node:
            nt.add_node(node, color='#ef476f', size=20)
        elif 'Manuf' in node:
            nt.add_node(node, color='#ffd166',size=20)
        elif 'Part' in node:
            nt.add_node(node, color='#06d6a0',size=20)
        elif 'Retail' in node:
            nt.add_node(node, color='#118ab2',size=20)
        else:
            nt.add_node(node, color='#073b4c',size=20)#Trans

    list_edges = zip(edges_data['source'],edges_data['target'])
    nt.add_edges(list_edges)
    nt.toggle_physics(True)
    nt.save_graph('html_SC_structure/instance'+instace+".html")
    
    nt = Network('1500px', '1500px', notebook=True, cdn_resources="remote", directed =True)
    #nt.repulsion()
    # populates the nodes and edges data structures
    for i in range(len(nodes_data.index)):
        if 'Dist' in nodes_data.iloc[i,0]:
            nt.add_node(nodes_data.iloc[i,0],color='#ef476f',size=20,x=int(nodes_data.iloc[i,22]),y=int(nodes_data.iloc[i,23]))
        elif 'Manuf' in nodes_data.iloc[i,0]:
            nt.add_node(nodes_data.iloc[i,0],color='#ffd166',size=20,x=int(nodes_data.iloc[i,22]),y=int(nodes_data.iloc[i,23]))
        elif 'Part' in nodes_data.iloc[i,0]:
            nt.add_node(nodes_data.iloc[i,0],color='#06d6a0',size=20,x=int(nodes_data.iloc[i,22]),y=int(nodes_data.iloc[i,23]))
        elif 'Retail' in nodes_data.iloc[i,0]:
            nt.add_node(nodes_data.iloc[i,0],color='#118ab2',size=20,x=int(nodes_data.iloc[i,22]),y=int(nodes_data.iloc[i,23]))
        else:
            nt.add_node(nodes_data.iloc[i,0],color='#073b4c',size=20,x=int(nodes_data.iloc[i,22]),y=int(nodes_
```



